############################################################## Input and Output ##################################################################

// These lines at the beginning of the code makes the input/output more efficient
ios::sync_with_stdio(0);
cin.tie(0);

Note: '\n' works faster than the endl, cuz endl always causes a flush operation

// scanf and printf are alternatives to cin and cout, and are faster
scanf("%d %d", &a, &b);
printf("%d %d\n", a, b);

// To take the whole line as input use the getline function
string s;
getline(cin, s);

//When you dont know the input amount of data use,
while(cin>>x){  // will take input one after the other until there is no more input left
  //code
}

// In some contest files are used for input and output. Then use this in the beginning of the code
// Then, write the code as usual with cin and cout
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);

################ Working with numbers ###################

##### Integer numbers

int is a 32bit ranging from -2^31 to 2^31-1 i.e around -2e9 to 2e9
long long varires from -9e18 to 9e18

##### Modular arithmetic:

// Some problems require you to calculate final_ans % m cuz final answer is too big, you need modular operations
(a + b) mod m = (a mod m + b mod m) mod m
(a − b) mod m = (a mod m − b mod m) mod m
(a · b) mod m = (a mod m · b mod m) mod m
// Thus we can take remainders after every operation and the numbers will never become too large

##### Floating point numbers:

64bit double 
80bit long double
// if there is a required precision use this
printf("%.9f\n", x);  // print x with 9 decimal places

// Comparing float numbers can lead to errors due to precision. 
// It is better to assume two floating numbers equal if difference b/w them is a small eps=e-9
if (abs(a-b) < 1e-9) {
  // a and b are equal
}

##### Shortening code:

// instead of using long long many times in your code. you can use typedef like //   This is known as TYPE NAMES
typedef long long ll;
ll a = 123456789;  //instead of long long a, long long b etc.
ll b = 987654321;
cout << a*b << "\n";

// Also works for complex stuff
typedef vector<int> vi;
typedef pair<int,int> pi;

// MACROS can be used to shorten your code further.
// for example

#define F first
#define S second
#define PB push_back
#define MP make_pair
#define REP(i,a,b) for (int i = a; i <= b; i++)

// this will convert 
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
for (int i = 1; i <= n; i++) {
  search(i);
}

// to
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
REP(i,1,n) {
  search(i);
}

################ Recursive algorithms ###################

Covered generating subsets, generating permutations, n-queens

################ Bit manipulation algorithms ###################

Internally every int is stored as a 32bit binary
Theres a relation between representations: signed number -x = unsigned number 2^n-x

The value of int goes from 0 to 2147483647(2^31-1). Then x++ would make its value -2147483648 and further counting downwards to 0

##### Bit Operations

1. And operation: if both have 1, then 1 else 0
  10110 (22)
& 11010 (26)
= 10010 (18)

Can be used to find if a number is even(if x&1==0)(for number to be divisible by 0 2^0 should be 0) or odd(if x&1==1)

2. Or operation: if one of them is 1, then 1 else 0

3. Xor operation: 1 where there is exactly one 1, else 0
  10110 (22)
ˆ 11010 (26)
= 01100 (12)

4. Not operation(~): ~ of a number is the negative of the number + 1
~x = −x −1  for ex: ~29 = −30
Basically reverse all the bits from 1 to 0 and viceversa

5. Bit shifts: 
    1. left bit shift x << k appends k zero bits to the number
        For example, 14 << 2 = 56, because 14 and 56 correspond to 1110 and 111000
        x << k corresponds to multiplying x by 2^k
    2. right bit shift x >> k removes the k last bits from the number
        49 >> 3 = 6, because 49 and 6 correspond to 110001 and 110
        x >> k corresponds to dividing x by 2k rounded down to an integer
  
6. Bit masks: A bit mask of the form 1 << k has a one bit in position k, and all other
   bits are zero, so we can use such masks to access single bits of numbers
   1. kth bit of a number is one exactly when x & (1 << k) is not zero
   2. x | (1 << k) sets the kth bit of x to one
   3. x & ~(1 << k) sets the kth bit of x to zero
   4. ˆ (1 << k) inverts the kth bit of x
   5. x & (x −1) sets the last one bit of x to zero
   6. x & −x sets all the one bits to zero, except for the last one bit
   7. x | (x − 1) inverts all the bits after the last one bit
   8. positive number x is a power of two exactly when x & (x − 1) = 0

##### Representing sets:

Every subset of a set {0,1,2,3...n-1} can be represented by a n bit number, whose 1 means the number is 
included and 0 means not.

Operation         Set syntax      Bit syntax
Intersection        a ∩ b           a & b
Union               a ∪ b           a | b
Complement            ¯a              ~a
Difference          a \ b           a & (~b)

for ex: 
int x = (1<<1)|(1<<3)|(1<<4)|(1<<8);
int y = (1<<3)|(1<<6)|(1<<8)|(1<<9);
int z = x|y; // z would be the union of x and y

################################################################# Efficiency #############################################################################

1 < logn < root(n) < n < nlongn < n^2 < n^3 < 2^n < n!

Input size          Expected time complexity
n ≤ 10                        O(n!)
n ≤ 20                        O(2n)
n ≤ 500                       O(n3)
n ≤ 5000                      O(n2)
n ≤ 106                 O(n log n) or O(n)
n is large              O(1) or O(log n)

Looked at maximumSubarraySum problem and 2-queens problem. 2-queens had a recursive and also a O(1) soln.

################################################################# Sorting and searching #############################################################################

bubble sort, gets is name from the largest number going to the end like bubble rising to the surface.
The lowest time for sorting which can be obtained by comparing cant go below nlogn

##### Sorting with vectors, arrays, strings

vector<int> v = {4,2,5,3,5,8,3};
sort(v.begin(),v.end());  // ascending
sort(v.rbegin(),v.rend());  // descending

int n = 7; // array size
int a[] = {4,2,5,3,5,8,3};
sort(a,a+n);

string s = "monkey";
sort(s.begin(), s.end());

vector<pair<int,int>> v;
v.push_back({1,5});
v.push_back({2,3});
v.push_back({1,2});
sort(v.begin(), v.end());
// result: [(1,2),(1,5),(2,3)]










